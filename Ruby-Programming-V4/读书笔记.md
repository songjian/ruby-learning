# Ruby基础教程v4

## 第5章 条件判断

### ruby的三种主要条件判断语句
* if
* unless
* case

### Ruby真假值
|真|假|
|--|--|
|真|false、nil以外的所有对象|
|假|false、nil|

#### if语句

```ruby
if 条件 then
end
```

then 可以省略

#### unless语句

条件为假时执行

```ruby
unless 条件 then
end
```
then 可以省略

#### case语句

```ruby
case 比较对象
when 值1 then
  处理1
when 值2 then
  处理2
when 值3 then
  处理3
else
  处理4
end
```

then 可以省略

### === 与 case
在case语句中，when判断值是否相等时，实际是使用===运算符来判断。左边是数值或字符串时，===与==意义一样，除此之外，===还可以与=~一样用来判断正则表达式是否匹配，或者判断右边的对象是否属于左边的类，等等。对比单纯的判断两边的值是否相等，===能表达更加广义的"相等"。

### eql? 判断值相等比 == 严谨
例如：0 与 0.0 和 1.0 与 1 eql? 返回 false  ==返回 true

## 第6章 循环

### 实现循环的方法

* times 方法
* while 语句
* each 方法
* for 语句
* until 语句
* loop 方法

#### times方法

```ruby
# 满地油菜花输出7遍
7.times do
  puts "满地油菜花"
end
```

得到当前的循环次数
```ruby
10.times do |i|
  puts i
end
```

#### for语句

for语句与times方法不一样，循环的开始值和结束值可以任意指定。

```ruby
sum = 0
for i in 1..5 do
  sum = sum + i
end
puts sum
```
do可以省略

计算变量from到变量to累加的总数
```ruby
from = 10
to = 20
sum = 0
for i in from..to
  sum = sum + i
end
puts sum
```

#### 普通for语句

```ruby
names = ["awk", "Perl", "Python", "Ruby"]
for name in names
  puts name
end
```

#### while语句

```ruby
i = 1
while i < 3
  puts i
  i += 1
end
```
#### until语句

until语句的结构与white完全一样，只是条件判断刚好相反，不满足条件时才执行循环处理

#### each方法

each方法将对象集合里的对象逐条取出

```ruby
names = ["awk", "Perl", "Python", "Ruby"]
names.each do |name|
  puts name
end
```

```ruby
sum = 0
(1..5).each do |i|
  sum = sum + i
end
puts sum
```

#### loop方法

loop方法没有终止条件，只是不断的执行循环

### 循环控制

* break 终止程序，跳出循环
* next 跳到下一次循环
* redo 在相同的条件下重复刚才的处理

#### break

break会终止全体循环程序

#### next

next会忽略next后面的部分，跳到下一个循环开始的部分

#### redo

redo和next非常像，与next不同之处是，redo会再执行一次相同的循环
break和next比较常用，redo在ruby默认提供的程序库里也很难找到踪影

### do ~ end 与 { ~ }

一般的约定

* 程序是跨行写的时候使用 do ~ end
* 程序写在1行的时候用 { ~}

## 第7章 方法

### 方法调用

```ruby
对象.方法名(参数1, 参数2, … ,参数n)
```

对象被称为接收者(receiver)。在面向对象的世界中，调用方法被称为『向对象发送消息（message）』，调用的结果就是『对象接收(receive)了消息』，也就是说，方法的调用就是把几个参数连同消息一起发送给对象的过程。

### 带块的方法调用

each 和 loop 等方法都属于带块的方法

使用do ~ end是，可以省略参数列表括起来的()。使用{~}时，只有在没有参数的时候才可以省略()。

### 运算符形式的方法调用

Ruby中有些方法看起来很像运算符。四则运算等的二元运算符、-（负号）等的一元运算符、指定数组、散列的元素下标的[]等，实际都是方法。

* obj + arg1
* obj =~ arg1
* -obj
* !obj
* obj[arg1]
* obj[arg1] = arg2

实际上可以将obj理解为接收者，将arg1、arg2理解为参数。

### 方法的分类

Ruby的方法分为3类：
* 实例方法
* 类方法
* 函数式方法

#### 实例方法

如果有一个对象的实例，那么以这个对象为接收者的方法就是实例方法。

```ruby
p "10, 20, 30, 40".split(",")
p [1, 2, 3, 4].index(2)
p 1000.to_s
```

#### 类方法

接收者不是对象而是类本身时的方法，是类方法。

```ruby
Array.new
File.open("some_file")
Time.now
```

调用类方法时，可以使用::代替.。Ruby语法中 :: 和 . 代表的意思是一样的。

#### 函数式方法

没有接收者的方法是函数式方法。

```ruby
print "hello!"
sleep(10)
```

函数式方法的执行结果，不会根据接收者的状态而发生变化。程序运行print方法以及sleep方法的时候，不需要知道接收者是谁。反过来说，不需要接收者的方法就是函数式方法。

#### Ruby帮助文档里实例方法的标记法

Ruby帮助文档里标记类的实例方法用Array#each、Array#inject写法。

### 方法的定义

定义方法的一般语法：
```ruby
def 方法名 (参数1， 参数2)
  希望执行的代码
end
```
方法名可以由英文字母、数字、下划线组成，但不能以数字开头。

方法有多个参数时，从参数列表右边开始依次指定默认值。

```ruby
def func(a, b=1, c=3)
end
```

#### 方法的返回值

可以用return指定方法的返回值

可以省略return语句，方法的最后一个表达式的结果作为方法的返回值

return语句可以马上终止程序

#### 定义带块的方法

```ruby
def myloop
  while true
    yield # 执行块
  end
end

num = 1   # 初始化num
myloop do
  puts "num is #{num}"
  break if num > 100     # num超过100时跳出循环
  num * 2
end
```

yield是定义块的关键字

#### 参数个数不确定的方法

通过 『\*变量名』 的形式来定义参数个数不确定的方法

```ruby
def foo(*args)
  args
end

p foo(1, 2, 3)   #=> [1, 2, 3]

def meth(arg, *args)
  [arg, args]
end

p meth(1)         #=> [1, []]
p meth(1, 2, 3)   #=>[1, [2, 3]]
```

#### 关键字参数

Ruby 2.0加入的新特性

```ruby
def 方法名(参数1:值, 参数2:值)
  代码逻辑
end
```

可以使用 『\*\*变量名』这种形式来接收未定义的参数

关键字参数可以与普通参数搭配使用

可以使用散列传递参数

#### 关于方法调用的一些补充

* 把数组分解为参数
* 把散列作为参数传递

### 如何书写简明易懂的程序

* 换行和;
  * 多使用换行作为语句的间隔
  * 除非必要，不使用;作为语句的间隔
* 缩进(indent)
  * 两个空白表示一个缩进
  * 需要使用缩进的情况：
    * 条件分支
    * 循环
    * 块
    * 方法、类等定义
  * 不要突然使用缩进
  * 确保缩进整齐
* 空白
  * 好的写法
    * a+b
    * a + b
  * 不好的写法
    * a +b
    * a+ b
* 良好的编码风格需要大量阅读其他人写的程序

## 第8章 类和模块

### 8.1 类是什么

#### 8.1.1

想知道某个对象属于哪个类，可以使用class方法

```ruby
ary = []
str = 'Hello World.'
p ary.class   #=> Array
p str.class   #=> String
```

判断某个对象是否属于某个类时，使用instance_of?方法

```ruby
ary = []
str = 'Hello World'
p ary.instance_of?(Array)   #=> true
p str.instance_of?(String)  #=> true
p ary.instance_of?(String)  #=> false
p str.instance_of?(Array)   #=> false
```

#### 8.1.2 继承

* 通过扩展已定义的类来创建新类称为继承
* 继承后创建创建的新类称为子类(subclass)
* 被继承的类称为父类(superclass)，也称超类
* 通过继承可以实现以下事情：
  * 在不影响原有功能的前提下追加新功能
  * 重新定义原有功能，使名称相同的方法产生不同的效果
  * 在已有功能的基础上追加处理，扩展已有功能
* BasicObject类是Ruby中所有类的父类，它定义了作为Ruby对象的最基本功能

### 8.2 类的创建

使用class关键字定义类

```ruby
class 类名
  类的定义
end
```
#### 8.2.2 initialize 方法

使用new方法生成新对象时，initialize方法会被调用，new方法的参数会原封不动的传给initialize方法

```ruby
 # initialize方法
def initialize(myname='Ruby')  
  @name=myname                  # 初始化实例变量
end
```

#### 8.2.3 实例变量与实例方法

实例方法在实例内可用

#### 8.2.4 存取器

```ruby
class HelloWorld

  # 获取name
  def name
    @name
  end

  # 修改name
  def name=(value)
    @name = value
  end
```

Ruby提供了简便的定义方法
* attr_reader 只读
* attr_writer 只写
* attr_accessor 读写

#### 8.2.5 特殊变量 self

self是引用对象本身的保留字，对它赋值，不会对本身的值有任何影响

#### 8.2.6 类方法

```ruby
class << HelloWorld
  def hello(name)
    puts "#{name} said hello."
  end
end

HelloWorld.hello('John')  #=> John said hello.

class HelloWorld
  class << self
    def hello(name)
      puts "#{name} said hello."
    end
  end
end

HelloWorld.hello('John')  #=> John said hello.

def HelloWorld.hello(name)
  puts "#{name} said hello."
end

HelloWorld.hello('John')  #=> John said hello.

class HelloWorld
  def self.hello(name)
    puts "#{name} said hello."
  end
end

HelloWorld.hello('John')  #=> John said hello.
```

#### 8.2.7 常量

```ruby
class HelloWorld
  Version = "1.0"
end
```

使用类常量

```ruby
p HelloWorld::Version    #=> "1.0"
```

#### 8.2.8 类变量

@@开头的变量称作类变量，类变量是该类所有实例的共享变量

```ruby
class HelloCount
  @@count = 0

  def HelloWorld.count
    @@count
  end

  def initialize(myname="Ruby")
    @name = myname
  end

  def hello
    @@count += 1
    puts "Hello, World. I am #{@name}.\n"
  end
end

bob = HelloCount.new("Bob")
alice = HelloCount.new("Alice")
ruby = HelloCount.new

p HelloCount.count  #=> 0
bob.hello
alice.hello
ruby.hello
p HelloCount.count  #=> 3
```

#### 8.2.9 限制方法的调用

限制方法的调用

* public 实例方法，对外部公开
* private 无法从实例外部访问
* protected 在同一个类中使用时，可做实例方法调用

### 8.3 扩展类

#### 8.3.1 在原有类基础上添加方法

给String类添加统计单词数实例方法

```ruby
class String
  def count_word
    ary = self.split(/\s+/) # 使用空格分割
    return ary.size         # 返回分割后数组元素总数
  end
end

str = "Just Another Ruby Newbie"
p str.count_word            #=> 4
```

#### 8.3.2 继承

定义继承时，在使用class关键字指定类名的同时指定父类名

```ruby
class 类名 < 父类名
  类定义
end
```

```ruby
class RingArray < Array
  def [](i)
    idx = i % size
    super(idx)
  end
end

wday = RingArray['日', '火', '水', '木', '金', '土']
p wday[6]   #=> '土'
p wday[11]  #=> '木'
p wday[15]  #=> '月'
p wday[-1]  #=> '土'
```

### 8.4 alias 与 undef

#### 8.4.1 alias

```ruby
alias 别名 原名     # 直接使用方法名
alias :别名 :原名   # 使用符号名
```

同一种功能设置多个名称时，我们使用alias

```ruby
class C1
  def hello
    "Hello"
  end
end

class C2 < C1
  alias old_hello hello

  def hello
    "#{old_hello}, again"
  end
end

obj = C2.new
p obj.old_hello
p obj.hello
```

#### 8.4.2 undef

undef用于删除已有方法的定义。

```ruby
undef 方法名    # 只用使用方法名
undef :方法名   # 使用符号名
```

## 8.5 模块

模块是Ruby的特色功能之一。如果说类变现的是事物的实体（数据）和行为（处理），那模块表现的就只是事物的行为部分。模块和类有两点不同：

* 模块不能拥有实例
* 模块不能被继承

## 8.6 模块的使用方法

### 8.6.1
